diff --git a/src/main.cpp b/src/main.cpp
index 96484dc..dbe5897 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -656,6 +656,8 @@ bool g_bRt = false;
 int g_argc;
 char **g_argv;
 
+bool g_bSupportsPresentWait = true;
+
 int main(int argc, char **argv)
 {
 	g_argc = argc;
@@ -824,9 +826,12 @@ int main(int argc, char **argv)
 			eCurrentBackend = gamescope::GamescopeBackend::DRM;
 	}
 
+	const bool bSupportsPresentWait = checkForPresentWaitExt();
+
 	if ( g_pOriginalWaylandDisplay != NULL )
 	{
-        if (CheckWaylandPresentationTime())
+        const bool bCompositor_supports_present_wait = CheckWaylandPresentationTime();
+        if (bCompositor_supports_present_wait && bSupportsPresentWait)
         {
             // Default to SDL_VIDEODRIVER wayland under Wayland and force enable vk_khr_present_wait
             // (not enabled by default in Mesa because instance does not know if Wayland
@@ -834,14 +839,30 @@ int main(int argc, char **argv)
             setenv("vk_khr_present_wait", "true", 0);
             setenv("SDL_VIDEODRIVER", "wayland", 0);
         }
-        else
-        {
+        else if (bSupportsPresentWait)
+		{
             fprintf(stderr,
                 "Your Wayland compositor does NOT support wp_presentation/presentation-time which is required for VK_KHR_present_wait and VK_KHR_present_id.\n"
                 "Please complain to your compositor vendor for support. Falling back to X11 window with less accurate present wait.\n");
             setenv("SDL_VIDEODRIVER", "x11", 1);
+        }
+		else if (!bSupportsPresentWait)
+        {
+        	fprintf(stderr,
+        		"Notice: GPU device does not support present_wait extension\n"
+        		"continuing with present_wait disabled.\n\n");
+        	 setenv("vk_khr_present_wait", "false", 1);
+        	 if (bCompositor_supports_present_wait)
+        	 	 setenv("SDL_VIDEODRIVER", "wayland", 0); //doing this for consistency, shouldn't cause any issues
         }
 	}
+	else if (!bSupportsPresentWait)
+    {
+    	fprintf(stderr,
+    		"Notice: GPU device does not support present_wait extension\n"
+    		"continuing with present_wait disabled.\n\n");
+    	 setenv("vk_khr_present_wait", "false", 1);
+    }
 
 	g_ForcedNV12ColorSpace = parse_colorspace_string( getenv( "GAMESCOPE_NV12_COLORSPACE" ) );
 
diff --git a/src/main.hpp b/src/main.hpp
index 2e6fb83..78d4d3b 100644
--- a/src/main.hpp
+++ b/src/main.hpp
@@ -26,6 +26,8 @@ extern bool g_bFullscreen;
 
 extern bool g_bGrabbed;
 
+extern bool g_bSupportsPresentWait;
+
 extern float g_mouseSensitivity;
 extern const char *g_sOutputName;
 
diff --git a/src/rendervulkan.cpp b/src/rendervulkan.cpp
index 63d34b3..a2a67bd 100644
--- a/src/rendervulkan.cpp
+++ b/src/rendervulkan.cpp
@@ -92,6 +92,7 @@ static const mat3x4& colorspace_to_conversion_from_srgb_matrix(EStreamColorspace
 
 PFN_vkGetInstanceProcAddr g_pfn_vkGetInstanceProcAddr;
 PFN_vkCreateInstance g_pfn_vkCreateInstance;
+PFN_vkDestroyInstance g_pfn_vkDestroyInstance;
 
 static VkResult vulkan_load_module()
 {
@@ -300,7 +301,8 @@ bool CVulkanDevice::BInit(VkInstance instance, VkSurfaceKHR surface)
 	std::thread piplelineThread([this](){compileAllPipelines();});
 	piplelineThread.detach();
 
-	g_reshadeManager.init(this);
+	if (m_supportsReshade)
+		g_reshadeManager.init(this);
 
 	return true;
 }
@@ -397,6 +399,53 @@ bool CVulkanDevice::selectPhysDev(VkSurfaceKHR surface)
 	return true;
 }
 
+void CVulkanDevice::prepare_tmp_dev(VkInstance tmp_instance)
+{
+	//g_output.surface = VK_NULL_HANDLE;
+	#define VK_FUNC(x) vk.x = (PFN_vk##x) g_pfn_vkGetInstanceProcAddr(tmp_instance, "vk"#x);
+	VULKAN_INSTANCE_FUNCTIONS
+	#undef VK_FUNC
+
+
+	m_instance = tmp_instance;
+
+	selectPhysDev(VK_NULL_HANDLE);
+}
+
+bool CVulkanDevice::_checkForPresentWaitExt()
+{
+	uint32_t supportedExtensionCount;
+	vk.EnumerateDeviceExtensionProperties( physDev(), NULL, &supportedExtensionCount, NULL );
+
+	std::vector<VkExtensionProperties> supportedExts(supportedExtensionCount);
+	vk.EnumerateDeviceExtensionProperties( physDev(), NULL, &supportedExtensionCount, supportedExts.data() );
+
+	bool bSupports_present_wait = false, bSupports_present_id = false;
+
+	for ( uint32_t i = 0; i < supportedExtensionCount; ++i )
+	{
+		if ( strcmp(supportedExts[i].extensionName, VK_KHR_PRESENT_ID_EXTENSION_NAME) == 0 )
+			bSupports_present_id = true;
+		else if ( strcmp(supportedExts[i].extensionName, VK_KHR_PRESENT_WAIT_EXTENSION_NAME) == 0)
+			bSupports_present_wait = true;
+	}
+
+	return bSupports_present_wait && bSupports_present_id;
+}
+
+bool checkForPresentWaitExt()
+{
+	VkInstance tmp_instance = vulkan_get_instance(true);
+	CVulkanDevice tmp_dev;
+	tmp_dev.prepare_tmp_dev(tmp_instance); //doesn't actually call vkCreateDevice(), just prepares CVulkanDevice object
+
+	g_bSupportsPresentWait = tmp_dev._checkForPresentWaitExt();
+
+	g_pfn_vkDestroyInstance(tmp_instance, 0);
+
+	return g_bSupportsPresentWait;
+}
+
 bool CVulkanDevice::createDevice()
 {
 	vk.GetPhysicalDeviceMemoryProperties( physDev(), &m_memoryProperties );
@@ -532,13 +581,20 @@ bool CVulkanDevice::createDevice()
 
 	std::vector< const char * > enabledExtensions;
 
+	auto append_if_supported = [bSupportsPresentWait=g_bSupportsPresentWait](std::vector<const char *>* dst, std::span<const char * const> src) {
+		static constexpr std::array<const char* const,2> checking_for = { VK_KHR_PRESENT_ID_EXTENSION_NAME, VK_KHR_PRESENT_WAIT_EXTENSION_NAME };
+		for (auto& ext : src) { 
+			if (bSupportsPresentWait || ( std::find(checking_for.begin(), checking_for.end(), ext) == checking_for.end() )  )
+				dst->push_back(ext);
+		}
+	};
+
 	if ( GetBackend()->UsesVulkanSwapchain() )
 	{
 		enabledExtensions.push_back( VK_KHR_SWAPCHAIN_EXTENSION_NAME );
 		enabledExtensions.push_back( VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME );
 
-		enabledExtensions.push_back( VK_KHR_PRESENT_ID_EXTENSION_NAME );
-		enabledExtensions.push_back( VK_KHR_PRESENT_WAIT_EXTENSION_NAME );
+		append_if_supported(&enabledExtensions, {{VK_KHR_PRESENT_ID_EXTENSION_NAME, VK_KHR_PRESENT_WAIT_EXTENSION_NAME}} );
 	}
 
 	if ( m_bSupportsModifiers )
@@ -560,8 +616,7 @@ bool CVulkanDevice::createDevice()
 	if ( supportsHDRMetadata )
 		enabledExtensions.push_back( VK_EXT_HDR_METADATA_EXTENSION_NAME );
 
-	for ( auto& extension : GetBackend()->GetDeviceExtensions( physDev() ) )
-		enabledExtensions.push_back( extension );
+	append_if_supported(&enabledExtensions, GetBackend()->GetDeviceExtensions( physDev() ) );
 
 #if 0
 	VkPhysicalDeviceMaintenance5FeaturesKHR maintenance5 = {
@@ -580,10 +635,19 @@ bool CVulkanDevice::createDevice()
 
 	VkPhysicalDevicePresentWaitFeaturesKHR presentWaitFeatures = {
 		.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR,
-		.pNext = &features13,
 		.presentWait = VK_TRUE,
 	};
 
+	VkPhysicalDeviceProperties props;
+	vk.GetPhysicalDeviceProperties(physDev(), &props);
+	m_vkApiVer = props.apiVersion;
+	if (VK_API_VERSION_MINOR(m_vkApiVer) >= 3)
+		presentWaitFeatures.pNext = &features13;
+	else if (VK_API_VERSION_MINOR(m_vkApiVer) < 2) {
+		vk_log.errorf("ERROR: gamescope requires device support for at least vulkan 1.2");
+		return false;
+	}
+
 	VkPhysicalDevicePresentIdFeaturesKHR presentIdFeatures = {
 		.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR,
 		.pNext = &presentWaitFeatures,
@@ -592,12 +656,14 @@ bool CVulkanDevice::createDevice()
 
 	VkPhysicalDeviceFeatures2 features2 = {
 		.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
-		.pNext = &presentIdFeatures,
 		.features = {
 			.shaderInt16 = m_bSupportsFp16,
 		},
 	};
 
+	if (g_bSupportsPresentWait)
+		features2.pNext = &presentIdFeatures;
+
 	VkDeviceCreateInfo deviceCreateInfo = {
 		.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
 		.pNext = &features2,
@@ -653,6 +719,16 @@ bool CVulkanDevice::createDevice()
 	VULKAN_DEVICE_FUNCTIONS
 	#undef VK_FUNC
 
+	if (VK_API_VERSION_MINOR(m_vkApiVer) >= 3)
+	{
+		#define VK_FUNC(x) vk.x = (PFN_vk##x) vk.GetDeviceProcAddr(device(), "vk"#x);
+		VULKAN_1_3_DEVICE_FUNCTIONS
+		#undef VK_FUNC
+		m_supportsReshade = true;
+	} else {
+		m_supportsReshade = false; //reshade effect manager uses vulkan 1.3 CmdBeginRendering/CmdEndRendering
+	}
+
 	vk.GetDeviceQueue(device(), m_queueFamily, 0, &m_queue);
 	if ( m_queueFamily == m_generalQueueFamily )
 		m_generalQueue = m_queue;
@@ -2950,16 +3026,22 @@ void vulkan_present_to_window( void )
 
 	VkPresentInfoKHR presentInfo = {
 		.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
-		.pNext = &presentIdInfo,
 		.swapchainCount = 1,
 		.pSwapchains = &g_output.swapChain,
 		.pImageIndices = &g_output.nOutImage,
 	};
 
+	bool bSupportsPresentWait = g_bSupportsPresentWait;
+
+	if (bSupportsPresentWait)
+		presentInfo.pNext = &presentIdInfo;
+
 	if ( g_device.vk.QueuePresentKHR( g_device.queue(), &presentInfo ) == VK_SUCCESS )
 	{
-		g_currentPresentWaitId = presentId;
-		g_currentPresentWaitId.notify_all();
+		if (bSupportsPresentWait) {
+			g_currentPresentWaitId = presentId;
+			g_currentPresentWaitId.notify_all();
+		}
 	}
 	else
 		vulkan_remake_swapchain();
@@ -3180,24 +3262,32 @@ bool vulkan_make_swapchain( VulkanOutput_t *pOutput )
 
 bool vulkan_remake_swapchain( void )
 {
-	std::unique_lock lock(present_wait_lock);
-	g_currentPresentWaitId = 0;
-	g_currentPresentWaitId.notify_all();
+	bool bRet;
 
-	VulkanOutput_t *pOutput = &g_output;
-	g_device.waitIdle();
-	g_device.vk.QueueWaitIdle( g_device.queue() );
+	auto doit = [&](std::function<void(void)> f) {
+		VulkanOutput_t *pOutput = &g_output;
+		g_device.waitIdle();
+		f();
+		pOutput->outputImages.clear();
+		g_device.vk.DestroySwapchainKHR( g_device.device(), pOutput->swapChain, nullptr );
 
-	pOutput->outputImages.clear();
+		// Delete screenshot image to be remade if needed
+		for (auto& pScreenshotImage : pOutput->pScreenshotImages)
+			pScreenshotImage = nullptr;
 
-	g_device.vk.DestroySwapchainKHR( g_device.device(), pOutput->swapChain, nullptr );
+		bRet = vulkan_make_swapchain( pOutput );
+		assert( bRet ); // Something has gone horribly wrong!
+	};
 
-	// Delete screenshot image to be remade if needed
-	for (auto& pScreenshotImage : pOutput->pScreenshotImages)
-		pScreenshotImage = nullptr;
+	if (g_bSupportsPresentWait) {
+		std::unique_lock lock(present_wait_lock);
+		g_currentPresentWaitId = 0;
+		g_currentPresentWaitId.notify_all();
+		doit( [&](){g_device.vk.QueueWaitIdle( g_device.queue() );});
+	} else {
+		doit([&](){return;});
+	}
 
-	bool bRet = vulkan_make_swapchain( pOutput );
-	assert( bRet ); // Something has gone horribly wrong!
 	return bRet;
 }
 
@@ -3421,9 +3511,9 @@ static bool init_nis_data()
 	return true;
 }
 
-VkInstance vulkan_get_instance( void )
-{
-	static VkInstance s_pVkInstance = []() -> VkInstance
+VkInstance vulkan_get_instance( bool isTemp )
+{ 
+	auto make_instance = [](bool isTemp) -> VkInstance
 	{
 		VkResult result = VK_ERROR_INITIALIZATION_FAILED;
 
@@ -3433,7 +3523,19 @@ VkInstance vulkan_get_instance( void )
 			return nullptr;
 		}
 
-		auto instanceExtensions = GetBackend()->GetInstanceExtensions();
+		uint32_t pApiVersion = 0;
+		PFN_vkEnumerateInstanceVersion vkEnumerateInstanceVersion;
+		if ( (vkEnumerateInstanceVersion = (PFN_vkEnumerateInstanceVersion) g_pfn_vkGetInstanceProcAddr(NULL, "vkEnumerateInstanceVersion")) == NULL) {
+			vk_log.errorf("ERROR: gamescope requires vulkan >= 1.2, instance only supports vulkan 1.0");
+			return nullptr;
+		}
+
+		vkEnumerateInstanceVersion(&pApiVersion);
+
+		if (VK_API_VERSION_MINOR(pApiVersion) < 2) {
+			vk_log.errorf("ERROR: gamescope requires device support for at least vulkan 1.2");
+			return nullptr;
+		}
 
 		const VkApplicationInfo appInfo = {
 			.sType              = VK_STRUCTURE_TYPE_APPLICATION_INFO,
@@ -3441,16 +3543,19 @@ VkInstance vulkan_get_instance( void )
 			.applicationVersion = VK_MAKE_VERSION(1, 0, 0),
 			.pEngineName        = "hopefully not just some code",
 			.engineVersion      = VK_MAKE_VERSION(1, 0, 0),
-			.apiVersion         = VK_API_VERSION_1_3,
-		};
+			.apiVersion         = VK_API_VERSION_MINOR(pApiVersion) > 3 ? VK_API_VERSION_1_3 : pApiVersion, //limit version to 1.3 in case vulkan 1.4 ever comes out		};
 
-		const VkInstanceCreateInfo createInfo = {
+		VkInstanceCreateInfo createInfo = {
 			.sType                   = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
 			.pApplicationInfo        = &appInfo,
-			.enabledExtensionCount   = (uint32_t)instanceExtensions.size(),
-			.ppEnabledExtensionNames = instanceExtensions.data(),
 		};
 
+		if (!isTemp) {
+			auto instanceExtensions = GetBackend()->GetInstanceExtensions();
+			createInfo.enabledExtensionCount   = (uint32_t)instanceExtensions.size();
+			createInfo.ppEnabledExtensionNames = instanceExtensions.data();
+		}
+
 		VkInstance instance = nullptr;
 		result = g_pfn_vkCreateInstance(&createInfo, 0, &instance);
 		if ( result != VK_SUCCESS )
@@ -3458,8 +3563,18 @@ VkInstance vulkan_get_instance( void )
 			vk_errorf( result, "vkCreateInstance failed" );
 		}
 
+		g_pfn_vkDestroyInstance = (PFN_vkDestroyInstance) g_pfn_vkGetInstanceProcAddr( instance, "vkDestroyInstance" );
+		if ( !g_pfn_vkDestroyInstance )
+			vk_log.errorf("failed to get address to vkDestroyInstance\n");
+
 		return instance;
-	}();
+	};
+
+	if (isTemp) {
+		return make_instance(true);
+	}
+
+	static VkInstance s_pVkInstance = make_instance(false);
 
 	return s_pVkInstance;
 }
@@ -3472,7 +3587,7 @@ bool vulkan_init( VkInstance instance, VkSurfaceKHR surface )
 	if (!init_nis_data())
 		return false;
 
-	if ( GetBackend()->UsesVulkanSwapchain() )
+	if ( GetBackend()->UsesVulkanSwapchain() && g_bSupportsPresentWait )
 	{
 		std::thread present_wait_thread( present_wait_thread_func );
 		present_wait_thread.detach();
@@ -3870,7 +3985,7 @@ std::optional<uint64_t> vulkan_composite( struct FrameInfo_t *frameInfo, gamesco
 	if (!frameInfo->applyOutputColorMgmt)
 		outputTF = EOTF_Count; //Disable blending stuff.
 
-	if (!g_reshade_effect.empty())
+	if (g_device.m_supportsReshade && !g_reshade_effect.empty())
 	{
 		if (frameInfo->layers[0].tex)
 		{
@@ -3892,7 +4007,7 @@ std::optional<uint64_t> vulkan_composite( struct FrameInfo_t *frameInfo, gamesco
 			}
 		}
 	}
-	else
+	else if (g_device.m_supportsReshade)
 	{
 		g_reshadeManager.clear();
 	}
diff --git a/src/rendervulkan.hpp b/src/rendervulkan.hpp
index f5fef30..86ce8ce 100644
--- a/src/rendervulkan.hpp
+++ b/src/rendervulkan.hpp
@@ -381,7 +381,7 @@ namespace CompositeDebugFlag
 	static constexpr uint32_t Tonemap_Reinhard = 1u << 7;
 };
 
-VkInstance vulkan_get_instance(void);
+VkInstance vulkan_get_instance(bool isTemp = false);
 bool vulkan_init(VkInstance instance, VkSurfaceKHR surface);
 bool vulkan_init_formats(void);
 bool vulkan_make_output();
@@ -650,7 +650,6 @@ static inline uint32_t div_roundup(uint32_t x, uint32_t y)
 	VK_FUNC(BeginCommandBuffer) \
 	VK_FUNC(BindBufferMemory) \
 	VK_FUNC(BindImageMemory) \
-	VK_FUNC(CmdBeginRendering) \
 	VK_FUNC(CmdBindDescriptorSets) \
 	VK_FUNC(CmdBindPipeline) \
 	VK_FUNC(CmdClearColorImage) \
@@ -658,7 +657,6 @@ static inline uint32_t div_roundup(uint32_t x, uint32_t y)
 	VK_FUNC(CmdCopyImage) \
 	VK_FUNC(CmdDispatch) \
 	VK_FUNC(CmdDraw) \
-	VK_FUNC(CmdEndRendering) \
 	VK_FUNC(CmdPipelineBarrier) \
 	VK_FUNC(CmdPushConstants) \
 	VK_FUNC(CreateBuffer) \
@@ -713,6 +711,12 @@ static inline uint32_t div_roundup(uint32_t x, uint32_t y)
 	VK_FUNC(WaitSemaphores) \
 	VK_FUNC(SetHdrMetadataEXT)
 
+#define VULKAN_1_3_DEVICE_FUNCTIONS \
+	VK_FUNC(CmdBeginRendering) \
+	VK_FUNC(CmdEndRendering)
+
+bool checkForPresentWaitExt();
+
 template<typename T, typename U = T>
 constexpr T align(T what, U to) {
 return (what + to - 1) & ~(to - 1);
@@ -739,10 +743,16 @@ struct VulkanTimelinePoint_t
 class CVulkanDevice
 {
 public:
+	bool m_supportsReshade = true;
 	bool BInit(VkInstance instance, VkSurfaceKHR surface);
+	bool BSupportsPresentWait();
+	
 
 	VkSampler sampler(SamplerState key);
 	VkPipeline pipeline(ShaderType type, uint32_t layerCount = 1, uint32_t ycbcrMask = 0, uint32_t blur_layers = 0, uint32_t colorspace_mask = 0, uint32_t output_eotf = EOTF_Gamma22, bool itm_enable = false);
+	
+	bool checkForPresentWaitExt();
+	
 	int32_t findMemoryType( VkMemoryPropertyFlags properties, uint32_t requiredTypeBits );
 	std::unique_ptr<CVulkanCmdBuffer> commandBuffer();
 	uint64_t submit( std::unique_ptr<CVulkanCmdBuffer> cmdBuf);
@@ -800,13 +810,20 @@ public:
 	{
 		VULKAN_INSTANCE_FUNCTIONS
 		VULKAN_DEVICE_FUNCTIONS
+		VULKAN_1_3_DEVICE_FUNCTIONS
 	} vk;
 	#undef VK_FUNC
 
+	uint32_t m_vkApiVer = 0;
+
 	void resetCmdBuffers(uint64_t sequence);
 
 protected:
 	friend class CVulkanCmdBuffer;
+	
+	void prepare_tmp_dev(VkInstance tmp_instance);
+	bool _checkForPresentWaitExt();
+	friend bool checkForPresentWaitExt();
 
 	bool selectPhysDev(VkSurfaceKHR surface);
 	bool createDevice();
